{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Prefect Qiskit","text":"<p>The <code>prefect-qiskit</code> integration makes it easy to write quantum computing workflow. You can use the Prefect version of Qiskit Primitives, which leverage the capabilities of workflow management software for robust execution.</p> <p>See Tutorials for full example.</p>"},{"location":"#qiskit-primitives","title":"Qiskit Primitives","text":"<p>Quantum Primitives are abstractions of quantum computation.  This model takes a Primitive Unified Bloc (PUB) as input and returns results depending on the input PUB type.  Typically, quantum programs are represented by the Quantum Circuit model. </p> <p>For example, the Qiskit implementation of this model may look like this:</p> <pre><code>from qiskit import QuantumCircuit\nfrom qiskit.primitives import BackendSamplerV2\nfrom qiskit.providers.fake_provider import GenericBackendV2\n\n# Define backend\nbackend = GenericBackendV2(2)\n\n# Create quantum circuit\ncirc = QuantumCircuit(2)\ncirc.h(0)\ncirc.cx(0, 1)\ncirc.measure_all()\n\n# Define Primitive\nprimitive = BackendSamplerV2(backend=backend)\npubs = [(circuit, )]\n\n# Execute\njob = primitive.run(pubs)\nresult = job.result()\n</code></pre>"},{"location":"#prefect-for-quantum-computing","title":"Prefect for Quantum Computing","text":"<p>As quantum computing technology advances, large-scale experiments are becoming more common. These experiments often involve repeated job execution on quantum processors, with readout data being processed remotely at scale. Given the high cost of quantum computation, it's prudent to implement robust execution practices at the application level, particularly for large experiments.</p> <p>To add robustness and scalability to your quantum computing workflow, integrating a cloud-native workflow orchestrator, such as Prefect, is a good option.  Prefect offers a framework for third-party integration,  which include, for example, AWS, Azure, and GCP.</p> <p>With Prefect, you can easily turn your existing codebase into a quantum computing workflow. For example, a common programming pattern in quantum workflow, called Qiskit Pattern, may look as below with the Prefect syntax.</p> <pre><code>from prefect import task, flow\n...\n\n@task\ndef mapping_problem(**params):\n    ...\n\n@task\ndef optimize(circuit, target):\n    ...\n\n@task\ndef post_processing(result):\n    ...\n\n@flow\ndef experiment(**params):\n    ...\n\n    # Qiskit Pattern: Mapping\n    circuit = mapping_problem(**params)\n\n    # Qiskit Pattern: Optimize\n    isa = optimize(circuit, target)\n\n    # Qiskit Pattern: Execute\n    result = runtime.sampler([isa])\n\n    # Qiskit Pattern: Post-Processing\n    data = post_processing(result)\n</code></pre>"},{"location":"#prefect-qiskit-integration","title":"Prefect Qiskit Integration","text":"<p>This plugin provides integration for quantum computation through the Primitive model with Qiskit implementation.  With this plugin, the Primitive execution in the example code may be simplified as below:</p> <pre><code>from prefect_qiskit import QuantumRuntime\n\nruntime = QuantumRuntime.load(\"my-runtime\")\n...\nresult = runtime.sampler(pubs)\n</code></pre> <p>Since our runtime is an asynchronous implementation, you can efficiently sample multiple PUBs in parallel:</p> <pre><code>import asyncio\n\nresults = await asyncio.gather(*[runtime.sampler([pub]) for pub in pubs])\n</code></pre> <p>See Asyncio task guide for Python syntax.</p> <p>As you may notice, the job object is encapsulated and the runtime directly returns the result.  Primitive execution is now implemented as a Prefect workflow to provide a checkpoint mechanism and repeat-until-success to mitigate execution failures. </p> <p>You can also pre- and post-process data with other third-party cloud integrations.</p>"},{"location":"#software-architecture","title":"Software Architecture","text":"<p>This diagram shows the software design of this plugin.</p> <p></p> <p>Users can use Qiskit to prepare PUBs.  If they already have a codebase written in Qiskit, they can easily turn the experiment into a Prefect workflow. </p> <p>The <code>QuantumRuntime</code> Block contains a vendor-specific credential Block,  and it spawns a client that implements the <code>AsyncRuntimeClientInterface</code> protocol against vendor-specific API. </p> <p>The <code>run_primitive</code> function (Primitive Runner Task), manages the execution on this abstraction layer.  Thanks to this abstraction, we can use a common Prefect workflow on different vendor APIs. </p> <p>When the runtime Block invokes a primitive, it calls the Prefect task with the credentials Block, PUBs, and vendor specific options. This task implements the checkpoint and repeat-until-success mechanism.</p>"},{"location":"#supported-vendors","title":"Supported Vendors","text":"<p>We support following quantum computing vendors.</p>"},{"location":"#qiskit-aer","title":"Qiskit Aer","text":"<p>Qiskit Aer is a high performance simulator for quantum circuits.</p> <pre><code>from prefect_qiskit.vendors.qiskit_aer import QiskitAerCredentials\n\ncredential = QiskitAerCredentials()\n</code></pre>"},{"location":"#ibm-quantum","title":"IBM Quantum","text":"<p>IBM Quantum provides quantum processors with superconducting qubit architecture.</p> <pre><code>from prefect_qiskit.vendors.ibm_quantum import IBMQuantumCredentials\n\ncredential = IBMQuantumCredentials(api_key=\"...\", crn=\"crn:...\")\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<p>For assistance using Qiskit, consult the Qiskit Documentation and, in particular, the Primitive Documentation.</p> <p>See the API specification of each quantum computer vendor for the data schema of primitive options. For IBM Quantum, checkout the REST API specification. </p>"},{"location":"contribution/","title":"Contribution Guidelines","text":""},{"location":"contribution/#open-pull-request","title":"Open Pull Request","text":"<p>If you'd like to contribute by fixing an issue or adding a new feature to <code>prefect-qiskit</code>,  please open a pull request from a fork of the repository. </p> <p>Follow these steps to open a pull request:</p> <ol> <li>Fork the repository:    Create a copy of the repository under your GitHub account.</li> <li>Clone the forked repository:    Download the repository to your local machine:    <pre><code>git clone git@github.com:&lt;your-github-account&gt;/prefect-qiskit.git\n</code></pre></li> <li>Install the repository with <code>dev</code> dependency:    <pre><code>pip install -e '.[dev]'\n</code></pre></li> <li>Update code:    Ensure functions and classes are documented and type hinted.</li> <li>Add tests:    Write tests that cover the new changes or bug fixes.    Confirm your changes don't break any test cases:    <pre><code>pytest tests/\n</code></pre></li> <li>Install <code>pre-commit</code>:    Perform code quality checks before committing:    <pre><code>pre-commit install\n</code></pre></li> <li>Commit and push:    Use <code>git add</code>, <code>git commit</code>, and <code>git push</code> to update your forked repository and open a pull request.</li> </ol>"},{"location":"contribution/#provide-vendor-implementation","title":"Provide Vendor Implementation","text":"<p>We welcome the implementation of clients for other quantum computing vendors.  Follow these instructions to add support for a new vendor.  Feel free to contact us via GitHub issues if you need support.</p>"},{"location":"contribution/#protocol-and-block","title":"Protocol and Block","text":"<p>A typical module structure for a specific vendor implementation looks like this:</p> <pre><code>prefect_qiskit\n\u2502   README.md\n\u2502   ...   \n\u2502\n\u2514\u2500\u2500\u2500vendors\n\u2502   \u2502   __init__.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500vendor_xyz\n\u2502       \u2502   __init__.py\n\u2502       \u2502   client.py\n\u2502       \u2502   credentials.py\n</code></pre> <ul> <li>Client file (<code>client.py</code>):   Implement the <code>AsyncRuntimeClientInterface</code> protocol, which is the core of your work.</li> <li>Credential file (<code>credentials.py</code>)   Implement the Prefect <code>CredentialsBlock</code> to store access credentials for your backend provider.</li> </ul> <p>After implementing the new credential block, add it to the <code>QuantumCredentialsT</code> alias in <code>prefect_qiskit.vendors.__init__.py</code>.  This allows <code>QuantumRuntime</code> to find the data model so that end users can set a credential for your provider on the Prefect console.</p>"},{"location":"contribution/#add-test-module","title":"Add Test Module","text":"<p>Add test cases for the new vendor to prevent future breaking API changes.  Create a new test module in <code>tests.vendors</code>.  Ideally, include at least one end-to-end test if it makes sense. </p> <p>Avoid including real credentials or tests relying on such credentials due to security concerns.  If you implement a client for REST API, you can dump the server response in JSON files and write practical test cases against this mock server.</p> <p>Warning</p> <p>Remove all secrets from test data to avoid any security risks.</p>"},{"location":"contribution/#misc","title":"Misc","text":"<p>Update the Supported Vendors list in documentation as well. Add the new vendor module to the API Reference.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#prefect_qiskit.runtime","title":"prefect_qiskit.runtime","text":"<p>This module provides an abstraction layer for managing the execution of Qiskit Primitives. Execution is managed by a Prefect task behind the scenes, enhancing system error resilience.</p> <p>The runtime supports both synchronous and asynchronous execution of primitives. Asynchronous execution is particularly efficient for I/O-bound tasks, typical in client-server remote computing scenarios.</p> <p>Users must supply Prefect credential blocks for the specific vendor to run on the target hardware.</p>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime","title":"QuantumRuntime","text":"<p>               Bases: <code>Block</code></p> <p>Prefect Block used to execute Qiskit Primitives on quantum computing resources. Quantum Runtime is a vendor agnostic implementation of primitive execution.</p> <p>Attributes:</p> Name Type Description <code>resource_name</code> <code>str</code> <p>Name of a quantum computing resource available with your credentials. Input value is validated and an error is raised when the resource name is not found.</p> <code>credentials</code> <code>QuantumCredentialsT</code> <p>Credentials to access the quantum computing resource from a target vendor.</p> <code>enable_job_analytics</code> <code>bool</code> <p>Enable quantum job analytics. When analytics is enabled, each primitive execution will create a table artifact 'job-metrics' that reports various execution metrics the vendor provides as a job metadata.</p> <code>max_retry</code> <code>int</code> <p>Maximum number of primitive execution retry on failure. Primitive execution raises an error after all executions fail or the error is not retryable.</p> <code>retry_delay</code> <code>int</code> <p>Standby time in seconds before creating new execution task on failure. This setting is applied only if the maximum retry is nonzero.</p> <code>timeout</code> <code>int | None</code> <p>Primitive execution timeout in seconds. Execution task will raise TaskRunTimeoutError after timeout. If the maximum number of reruns has not been reached, the error is also suppressed and new execution task is created.</p> <code>execution_cache</code> <code>bool</code> <p>Cache primitive execution result in a local file system. A cache key is computed from the input Primitive Unified Blocs, options, and resource name. Overhead of the primitive operands evaluation is incurred.</p> Example <p>Load stored Quantum Runtime and run Qiskit sampler primitive.</p> <pre><code>from prefect_qiskit.runtime import QuantumRuntime\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n\nruntime = QuantumRuntime.load(\"BLOCK_NAME\")\n\nvqc = QuantumCircuit(2)\nvqc.h(0)\nvqc.cx(0, 1)\nvqc.measure_all()\n\npm = generate_preset_pass_manager(optimization_level=2, target=runtime.get_target())\n\nresult = runtime.sampler(pm.run([vqc]))\n</code></pre>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime.async_estimator","title":"async_estimator  <code>async</code>","text":"<pre><code>async_estimator(estimator_pubs, options=None, tags=None)\n</code></pre> <p>Asynchronously run estimator primitive.</p> <p>Parameters:</p> Name Type Description Default <code>estimator_pubs</code> <code>list[SamplerPubLike]</code> <p>Operands of estimator primitive.</p> required <code>options</code> <code>dict | None</code> <p>Vendor-specific primitive options.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Arbitrary labels to add to the Primitive task tags of execution.</p> <code>None</code> <p>Returns:</p> Type Description <code>PrimitiveResult</code> <p>Qiskit PrimitiveResult object.</p>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime.async_get_target","title":"async_get_target  <code>async</code>","text":"<pre><code>async_get_target()\n</code></pre> <p>Asynchronously get Qiskit Target of specific backend.</p> <p>Returns:</p> Type Description <code>Target</code> <p>Qiskit Target object.</p>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime.async_sampler","title":"async_sampler  <code>async</code>","text":"<pre><code>async_sampler(sampler_pubs, options=None, tags=None)\n</code></pre> <p>Asynchronously run sampler primitive.</p> <p>Parameters:</p> Name Type Description Default <code>sampler_pubs</code> <code>list[SamplerPubLike]</code> <p>Operands of sampler primitive.</p> required <code>options</code> <code>dict | None</code> <p>Vendor-specific primitive options.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Arbitrary labels to add to the Primitive task tags of execution.</p> <code>None</code> <p>Returns:</p> Type Description <code>PrimitiveResult</code> <p>Qiskit PrimitiveResult object.</p>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime.build_runner_task","title":"build_runner_task","text":"<pre><code>build_runner_task(**kwargs)\n</code></pre> <p>Build Prefect Task object that runs primitive.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>Keyword arguments to instantiate Prefect Task.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Task</code> <p>A configured prefect task.</p>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime.estimator","title":"estimator","text":"<pre><code>estimator(estimator_pubs, options=None, tags=None)\n</code></pre> <p>Run estimator primitive.</p> <p>Parameters:</p> Name Type Description Default <code>estimator_pubs</code> <code>list[EstimatorPubLike]</code> <p>Operands of estimator primitive.</p> required <code>options</code> <code>dict | None</code> <p>Vendor-specific primitive options.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Arbitrary labels to add to the Primitive task tags of execution.</p> <code>None</code> <p>Returns:</p> Type Description <code>PrimitiveResult</code> <p>Qiskit PrimitiveResult object.</p>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime.get_target","title":"get_target","text":"<pre><code>get_target()\n</code></pre> <p>Get Qiskit Target of specific backend.</p> <p>Returns:</p> Type Description <code>Target</code> <p>Qiskit Target object.</p>"},{"location":"reference/#prefect_qiskit.runtime.QuantumRuntime.sampler","title":"sampler","text":"<pre><code>sampler(sampler_pubs, options=None, tags=None)\n</code></pre> <p>Run sampler primitive.</p> <p>Parameters:</p> Name Type Description Default <code>sampler_pubs</code> <code>list[SamplerPubLike]</code> <p>Operands of sampler primitive.</p> required <code>options</code> <code>dict | None</code> <p>Vendor-specific primitive options.</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>Arbitrary labels to add to the Primitive task tags of execution.</p> <code>None</code> <p>Returns:</p> Type Description <code>PrimitiveResult</code> <p>Qiskit PrimitiveResult object.</p>"},{"location":"reference/#prefect_qiskit.vendors","title":"prefect_qiskit.vendors","text":"<p>This module implements credentials for each quantum computing vendor, following the Prefect <code>CredentialsBlock</code> structure. Users can create and store these credentials on the Prefect server.</p> <p>The block must implement the <code>.get_client</code> method, which returns a client instance for the vendor-specific API, adhering to the <code>AsyncRuntimeClientInterface</code> protocol. This client is used by the primitive runner task and is not exposed externally. Although users can access the client instance via this method, it should be considered a private class and may be subject to future API changes without deprecation.</p>"},{"location":"reference/#prefect_qiskit.vendors.IBMQuantumCredentials","title":"IBMQuantumCredentials","text":"<p>               Bases: <code>CredentialsBlock</code></p> <p>Block used to manage runtime service authentication with IBM Quantum.</p> <p>Attributes:</p> Name Type Description <code>api_key</code> <code>SecretStr</code> <p>API key to access IBM Quantum Platform.</p> <code>crn</code> <code>str</code> <p>Cloud resource name to identify the service to use.</p> <code>auth_url</code> <code>HttpUrl | None</code> <p>A custom endpoint URL for IAM authentication.</p> <code>runtime_url</code> <code>HttpUrl | None</code> <p>A custom endpoint URL for Qiskit Runtime API.</p> Example <p>Load stored IBM Quantum credentials:</p> <pre><code>from prefect_qiskit.vendors.ibm_quantum import IBMQuantumCredentials\n\nquantum_credentials = IBMQuantumCredentials.load(\"BLOCK_NAME\")\n</code></pre>"},{"location":"reference/#prefect_qiskit.vendors.IBMQuantumCredentials.get_client","title":"get_client","text":"<pre><code>get_client()\n</code></pre> <p>Get IBM Runtime REST API client.</p>"},{"location":"reference/#prefect_qiskit.vendors.QiskitAerCredentials","title":"QiskitAerCredentials","text":"<p>               Bases: <code>CredentialsBlock</code></p> <p>Block used to emulate a runtime with the Qiskit Aer simulator. This block provides a virtual system configuration to produce a circuit ISA.</p> <p>Attributes:</p> Name Type Description <code>num_qubits</code> <code>int</code> <p>Number of qubits involved in the simulation. The host machine or computing node must have enough memory to represent qubit states, otherwise workflow execution may hang up.</p> <code>basis_gates</code> <code>list[str]</code> <p>A list of quantum gate opcode to form a basis gate set. The 'delay', 'measure', and 'reset' instruction are included without being specified here.</p> <code>noise</code> <code>bool</code> <p>Simulate noise during quantum gate operation. The depolarizing error is considered for gates, and the assignment error is considered for measurements. See the API doc for NoiseModel in Qiskit Aer for more details.</p> <code>coupling_map_type</code> <code>Literal['full', 'ring', 'linear']</code> <p>Topology of coupling map. Actual connections are automatically generated from the selected topology.</p> Example <p>Load stored Qiskit Aer credentials:</p> <pre><code>from prefect_qiskit.vendors.qiskit_aer import QiskitAerCredentials\n\nquantum_credentials = QiskitAerCredentials.load(\"BLOCK_NAME\")\n</code></pre>"},{"location":"reference/#prefect_qiskit.vendors.QiskitAerCredentials.get_client","title":"get_client","text":"<pre><code>get_client()\n</code></pre> <p>Get a mock runtime client running the Aer simulator.</p>"},{"location":"reference/#prefect_qiskit.primitives","title":"prefect_qiskit.primitives","text":"<p>This module manages the execution of Primitives using Prefect.</p> <p>Vendor-specific job handling is encapsulated within Prefect tasks, following a common job handling pattern in Prefect.</p>"},{"location":"reference/#prefect_qiskit.primitives.PrimitiveJob","title":"PrimitiveJob","text":"<p>               Bases: <code>JobBlock</code></p> <p>Prefect-style definition of a single primitive job.</p> <p>Although the job handling logic is backend-agnostic, users can provide vendor-specific credentials and execution options to communicate with target hardware via the runtime client API.</p> <p>Attributes:</p> Name Type Description <code>resource_name</code> <code>str</code> <p>A target hardware name available with the given credentials.</p> <code>credentials</code> <code>CredentialsBlock</code> <p>A vendor specific credentials that provides a runtime client API.</p> <code>primitive_blocs</code> <code>list[SamplerPub] | list[EstimatorPub]</code> <p>Canonical Qiskit Primitive Unified Blocs data.</p> <code>options</code> <code>dict | None</code> <p>A vendor specific execution options for primitives.</p> <code>program_type</code> <code>Literal['estimator', 'sampler']</code> <p>Reserved primitive name to run on runtime client API.</p> <code>job_watch_poll_interval</code> <code>float</code> <p>The amount of time to wait between runtime client API calls during monitoring.</p>"},{"location":"reference/#prefect_qiskit.primitives.PrimitiveJob.trigger","title":"trigger  <code>async</code>","text":"<pre><code>trigger()\n</code></pre> <p>Triggers a job run in an external service and returns a PrimitiveJobRun object to track the execution of the run.</p>"},{"location":"reference/#prefect_qiskit.primitives.PrimitiveJobRun","title":"PrimitiveJobRun","text":"<p>               Bases: <code>BaseModel</code>, <code>JobRun</code></p> <p>A handler of running Primitive Job.</p> <p>Tip</p> <p>You can directly retrieve the result of the job by using Job ID.</p> <pre><code>from prefect_qiskit.primitives import PrimitiveJobRun\nfrom prefect_qiskit.vendors.ibm_quantum import IBMQuantumCredentials\n\njob = PrimitiveJobRun(\n    job_id=\"d0a61oqorbds73c39gt0\",\n    credentials=IBMQuantumCredentials.load(\"my-ibm-client\"),\n)\nresult = await job.fetch_result()\n</code></pre> <p>Attributes:</p> Name Type Description <code>job_id</code> <code>str</code> <p>The unique identifier of the running job.</p> <code>job_watch_poll_interval</code> <code>float</code> <p>The amount of time to wait between Runtime API calls during monitoring.</p> <code>credentials</code> <code>CredentialsBlock</code> <p>A vendor specific credentials that provides a runtime client API.</p>"},{"location":"reference/#prefect_qiskit.primitives.PrimitiveJobRun.fetch_metrics","title":"fetch_metrics  <code>async</code>","text":"<pre><code>fetch_metrics()\n</code></pre> <p>Fetch JobMetrics object from server.</p>"},{"location":"reference/#prefect_qiskit.primitives.PrimitiveJobRun.fetch_result","title":"fetch_result  <code>async</code>","text":"<pre><code>fetch_result()\n</code></pre> <p>Fetch Qiskit PrimitiveResult object from server.</p>"},{"location":"reference/#prefect_qiskit.primitives.PrimitiveJobRun.wait_for_completion","title":"wait_for_completion  <code>async</code>","text":"<pre><code>wait_for_completion()\n</code></pre> <p>Asynchronously wait for the job to complete.</p>"},{"location":"reference/#prefect_qiskit.primitives.run_primitive","title":"run_primitive  <code>async</code>","text":"<pre><code>run_primitive(*, primitive_blocs, program_type, resource_name, credentials, enable_analytics=True, options=None)\n</code></pre> <p>A core logic to make a primitive job and returns a result.</p> <p>This function manages the execution of Qiskit Primitives on an abstract layer, providing built-in execution failure protection.</p> <p>It accepts PUBs and options, submitting this data to quantum computers via the vendor's API. The response is formatted into a Qiskit PrimitiveResult instance.</p> <p>If the job is successful and the <code>enable_analytics</code> flag is set, the task will analyze job metadata, create a job-metrics artifact, and save it on the Prefect server.</p> <p>Parameters:</p> Name Type Description Default <code>primitive_blocs</code> <code>list[SamplerPub] | list[EstimatorPub]</code> <p>Input sampler PUBs.</p> required <code>program_type</code> <code>Literal['sampler', 'estimator']</code> <p>Primitive ID.</p> required <code>resource_name</code> <code>str</code> <p>Quantum computing resource.</p> required <code>credentials</code> <code>CredentialsBlock</code> <p>Runtime API credentials.</p> required <code>enable_analytics</code> <code>bool</code> <p>Set True to generate table artifact of job metrics.</p> <code>True</code> <code>options</code> <code>dict | None</code> <p>Vendor-specific primitive options.</p> <code>None</code> <p>Returns:</p> Type Description <code>PrimitiveResult</code> <p>Qiskit PrimitiveResult object.</p>"},{"location":"reference/#prefect_qiskit.models","title":"prefect_qiskit.models","text":"<p>This module abstracts the runtime client interface and common data structures.</p> <p>The Quantum Runtime implementation for Prefect adheres to the Qiskit programming model for quantum primitives, which is vendor hardware agnostic.</p> <p>Primitives utilize Primitive Unified Blocs (PUBs) along with an execution options dictionary. Execution options can specify a vendor-specific schema based on supported features, such as built-in error mitigations.</p> <p>This module defines the protocol for API adapters that Prefect primitives can use. The protocol does not specify actual communication methods, allowing hardware vendors to implement any protocols, such as RESTful or gRPC, to interact with their hardware. All methods are asynchronous to leverage Prefect's native async support.</p>"},{"location":"reference/#prefect_qiskit.models.JOB_STATUS","title":"JOB_STATUS  <code>module-attribute</code>","text":"<pre><code>JOB_STATUS = Literal['QUEUED', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED']\n</code></pre> <p>Reserved status string of runtime job.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface","title":"AsyncRuntimeClientInterface","text":"<p>               Bases: <code>Protocol</code></p> <p>Interface abstraction of runtime client API version 1.</p> <p>A hardware vendor must provide a credential Block along with its API client that implements all the interfaces defined with this protocol.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface.check_resource_available","title":"check_resource_available  <code>async</code>","text":"<pre><code>check_resource_available(resource_name)\n</code></pre> <p>Asynchronously check whether the target resource is currently available.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Name of quantum computing resource.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True when resource is currently available.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface.get_job_metrics","title":"get_job_metrics  <code>async</code>","text":"<pre><code>get_job_metrics(job_id)\n</code></pre> <p>Asynchronously get metrics of Job.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Unique identifier of the job.</p> required <p>Returns:</p> Type Description <code>JobMetrics</code> <p>Execution metrics of the job when available.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface.get_job_status","title":"get_job_status  <code>async</code>","text":"<pre><code>get_job_status(job_id)\n</code></pre> <p>Asynchronously get status string of Job ID.</p> <p>Note</p> <p>This function raises error immediately when a job failure occurs. A client must inspect whether the job is retriable or not. In case the job is retriable, a downstream primitive runner will resubmit the same job data to the server.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Unique identifier of the job.</p> required <p>Raises:</p> Type Description <code>RuntimeJobFailure</code> <p>When job execution fails.</p> <p>Returns:</p> Type Description <code>JOB_STATUS</code> <p>Job status literal.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface.get_primitive_result","title":"get_primitive_result  <code>async</code>","text":"<pre><code>get_primitive_result(job_id)\n</code></pre> <p>Asynchronously get Qiskit PrimitiveResult object from complete Job ID.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Unique identifier of the job.</p> required <p>Returns:</p> Type Description <code>PrimitiveResult</code> <p>Qiskit PrimitiveResult object.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface.get_resources","title":"get_resources  <code>async</code>","text":"<pre><code>get_resources()\n</code></pre> <p>Asynchronously list available resource names for this client.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of resource names under this account.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface.get_target","title":"get_target  <code>async</code>","text":"<pre><code>get_target(resource_name)\n</code></pre> <p>Asynchronously get Qiskit Target for a specific computing resource.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Name of quantum computing resource.</p> required <p>Returns:</p> Type Description <code>Target</code> <p>Qiskit Target.</p>"},{"location":"reference/#prefect_qiskit.models.AsyncRuntimeClientInterface.run_primitive","title":"run_primitive  <code>async</code>","text":"<pre><code>run_primitive(program_id, inputs, resource_name, options)\n</code></pre> <p>Asynchronously send Primitive Blocs via Runtime API and return Job ID.</p> <p>Parameters:</p> Name Type Description Default <code>program_id</code> <code>Literal['sampler', 'estimator']</code> <p>Type of primitive to use.</p> required <code>inputs</code> <code>list[SamplerPub] | list[EstimatorPub]</code> <p>Qiskit Pub payloads that the primitive API will digest.</p> required <code>resource_name</code> <code>str</code> <p>Name of quantum computing resource.</p> required <code>options</code> <code>dict[str, Any]</code> <p>Execution options.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Job ID.</p>"},{"location":"reference/#prefect_qiskit.models.JobMetrics","title":"JobMetrics","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A canonical job metrics template. Vendor can provide following data if available. Provided information is consumed by the primitive runner to create a job metrics artifact.</p> <p>Attributes:</p> Name Type Description <code>qpu_usage</code> <code>float | None</code> <p>Duration that a quantum processor was actively running.</p> <code>timestamp_created</code> <code>datetime | None</code> <p>Time when the user job was created in the queue.</p> <code>timestamp_started</code> <code>datetime | None</code> <p>Time when the execution started on the control server.</p> <code>timestamp_completed</code> <code>datetime | None</code> <p>Time when the QPU execution completed on the control server.</p>"},{"location":"reference/#prefect_qiskit.exceptions","title":"prefect_qiskit.exceptions","text":"<p>This module defines custom exceptions.</p>"},{"location":"reference/#prefect_qiskit.exceptions.RuntimeJobFailure","title":"RuntimeJobFailure","text":"<p>               Bases: <code>Exception</code></p> <p>A custom exception to enable fine-grained control of Prefect task retries.</p> <p>All exceptions raised within the implementation of <code>AsyncRuntimeClientInterface</code> must be type cast into this exception. This exception includes a <code>retry</code> flag, allowing the Prefect primitive runner to determine whether to retry the task upon encountering an exception.</p> <p>For instance, if a user creates invalid PUB data, the task execution is unlikely to succeed. In such cases, the error from PUB validation should be type cast into <code>RuntimeJobFailure</code> with <code>retry=False</code>.</p>"},{"location":"reference/#prefect_qiskit.exceptions.RuntimeJobFailure.__init__","title":"__init__","text":"<pre><code>__init__(reason, job_id=None, error_code=None, retry=True)\n</code></pre> <p>Define exception.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>A human readable explanation of the failure.</p> required <code>job_id</code> <code>str | None</code> <p>Failed Job ID.</p> <code>None</code> <code>error_code</code> <code>str | None</code> <p>Vendor-specific error code.</p> <code>None</code> <code>retry</code> <code>bool</code> <p>Either retry the primitive execution or not.</p> <code>True</code>"},{"location":"tutorials/01_getting_started/","title":"01. Getting Started Introduction to Prefect Qiskit","text":"<p>This tutorial covers the end-to-end procedures for running a quantum experiment as a workflow.  The workflow runs locally on your laptop.</p>"},{"location":"tutorials/01_getting_started/#setup","title":"Setup","text":"<p>We recommend creating a dedicated virtual environment to install the plugin.  This helps isolate dependencies and avoid conflicts with other projects. Since both Prefect and Qiskit are dependencies, you don't need to install them separately.</p> <p>Note</p> <p>This software requires Python 3.10+</p> Python venvuv <pre><code>python3.10 -m venv quantum_workflow\nsource quantum_workflow/bin/activate\npip install prefect-qiskit\n</code></pre> <pre><code>uv venv quantum_workflow -p 3.10\nsource quantum_workflow/bin/activate\nuv pip install prefect-qiskit\n</code></pre> <p>Create a new Prefect profile for this tutorial.  We use localhost for this example, but you can also use Prefect Cloud for more advanced features and scalability.</p> <pre><code>prefect profile create qiskit\nprefect profile use qiskit\nprefect config set PREFECT_API_URL='http://127.0.0.1:4200/api'\n</code></pre> <p>Start the Prefect server. You may need to wait a little while for the server to come up.</p> <pre><code>prefect server start --host 127.0.0.1 --background\n</code></pre> <p>Register Prefect Blocks for Qiskit integrations.  This will register the <code>QuantumRuntime</code> block and credential blocks for specific hardware vendors.</p> <pre><code>prefect block register -m prefect_qiskit\nprefect block register -m prefect_qiskit.vendors\n</code></pre> <p>Now you can find the Prefect console at http://127.0.0.1:4200/dashboard.</p>"},{"location":"tutorials/01_getting_started/#write-a-workflow-script","title":"Write a workflow script","text":"<p>Create a Python file.</p> <pre><code>touch my-workflow.py\n</code></pre> <p>Add the following code block to the script file.</p> my-workflow.py<pre><code>from prefect import flow, task\nfrom prefect.variables import Variable\nfrom prefect.logging import get_run_logger\nfrom prefect_qiskit import QuantumRuntime\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.transpiler import generate_preset_pass_manager\n\n\n@task\ndef transpile_task(circuit, target):\n    pm = generate_preset_pass_manager(\n        optimization_level=2,\n        target=target,\n    )\n    return pm.run(circuit)\n\n\n@flow\ndef sample_bell():\n    logger = get_run_logger()\n\n    # 1. Load QuantumRuntime from Prefect Server\n    runtime = QuantumRuntime.load(\"default-runtime\")\n    options = Variable.get(\"sampler_options\")\n\n    # 2. Create ISA quantum circuit\n    bell = QuantumCircuit(2)\n    bell.h(0)\n    bell.cx(0, 1)\n    bell.measure_all()\n    isa_circ = transpile_task(\n        circuit=bell, \n        target=runtime.get_target(),\n    )\n\n    # 3. Execute workflow sampler\n    result = runtime.sampler([isa_circ], options=options)\n    logger.info(result[0].data.meas.get_counts())\n\n\n# Run the flow\nif __name__ == \"__main__\":\n    sample_bell()\n</code></pre> <p>Tip</p> <p>In above example code, the program loads <code>runtime</code> and <code>options</code> data from the Prefect server. This is a common practice in writing good software, where the configuration data is stored separately from the program,  instead of hard-coding the configuration as part of the code.  We will define configuration data later on the Prefect console.</p>"},{"location":"tutorials/01_getting_started/#use-qiskit-aer","title":"Use Qiskit Aer","text":"<p>Qiskit Aer is a popular circuit simulator for Qiskit. We start from testing the workflow with the simulator because real quantum processors may have a limited execution time allocation.</p> <p>Before running your script, you need to provide configuration data.  Open the Prefect console and navigate to the Blocks tab.  Then, click the \"Add Block\" button and enter \"Qiskit Aer Credentials\" in the search window.  Click the \"Create\" button on the card and fill in the necessary information as below.</p> <p></p> <p>Setup the Aer credential with the following information.</p> <pre><code>Block Name: \"my-aer-client\"\nNumber of Qubits: 2\nBasis Gates: [\"rz\", \"sx\", \"x\", \"cz\"]\nApply Noise: true\nCoupling Map Type: \"linear\"\n</code></pre> <p>Go back to the Blocks page, and create another block for Quantum Runtime.  You can choose the <code>my-aer-client</code> from a drop-down menu.</p> <p></p> <p>Set up the runtime with the following information.  Note that the block name must be <code>default-runtime</code> to align with the workflow script. For Aer simulator, only <code>aer_simulator</code> is accepted for the resource name.</p> <pre><code>Block Name: \"default-runtime\"\nResource Name: \"aer_simulator\"\nQuantum Runtime Credentials: my-aer-client\nJob Analytics: true\nMax Primitive Retry: 5\nRetry Delay: 300\nExecution Timeout: null\nExecution Cache: false\n</code></pre> <p>When the Blocks are created successfully, the console may look like this.</p> <p></p> <p>Next, create Prefect Variables. Navigate to the Variables tab and click the \"Add Variable\" button.  The Blocks are typed configuration documents with schema, and the Variables are free-form JSON input. </p> <p>Create a new Variable with the following information.</p> <pre><code>Name: \"sampler_options\"\nValue: {\"default_shots\": 3000}\n</code></pre> <p>Note</p> <p>Because primitive options are vendor-specific values, the common interface of runtime is designed to take a free-form dictionary.  Schema validation is applied after the data is passed to the vendor-specific implementation of the runtime.  Please refer to the runtime specification of each vendor for the data schema of primitive options.</p> <p>Now you are ready to run the workflow with the Aer backend. Go back to the terminal and enter the command.</p> <pre><code>python my-workflow.py\n</code></pre> <p>Navigate to the Run tab of the console,  and you will find a new entry for the <code>sample-bell</code> workflow with auto-generated unique name.</p> <p></p> <p>Click the task name to open the status of the workflow execution.  You can check logs and artifacts.  If your workflow has input parameters, these are also recorded in the Parameters tab.</p> <p></p> <p>With the above runtime settings, a <code>job-metrics</code> artifact is automatically created, and you can find it in the Artifacts tab. This artifact shows statistics of quantum job execution.</p>"},{"location":"tutorials/01_getting_started/#use-ibm-quantum","title":"Use IBM Quantum","text":"<p>We will run the same workflow on one of the IBM Quantum devices. Visit to the IBM Quantum Platform to generate an API key and copy the cloud resolution name (CRN) of your instance.  Check out the IBM Documentation for details.  A list of resource names are also available on your quantum instance.</p> <p>As with the Qiskit Aer Credentials, find \"IBM Quantum Credentials\" from the Block catalogue.  Create a new Block with the API key and CRN.  The URLs for the authentication endpoint and runtime endpoint can be left empty unless you need custom endpoints.</p> <pre><code>Block Name: \"my-ibm-client\"\nAPI Key: &lt;your api key&gt;\nCloud Resolution Name: &lt;your crn&gt;\nAuthentication Endpoint URL: null\nRuntime Endpoint URL: null\n</code></pre> <p>On the <code>default-runtime</code> Block window, click \"Edit\" to replace the Aer credentials with the IBM credentials.</p> <p></p> <p>Choose the <code>my-ibm-client</code> from the drop-down menu. Also, replace the Resource Name value with one of the available resources in your cloud instance (e.g. <code>ibm_torino</code>). Save it after the credential and resource name are updated.</p> <p>Then, edit the <code>sampler_options</code> Variable with the new value. The following format conforms to the IBM Quantum Runtime API data schema.</p> <pre><code>Name: \"sampler_options\"\nValue: {\"params\": {\"shots\": 3000}}\n</code></pre> <p>Go back to terminal and enter the command.</p> <pre><code>python my-workflow.py\n</code></pre> <p>Now you are running the same experiment on real quantum hardware.  In this way, you can run experiments on any hardware or with any sampler options without editing the source code.</p> <p>After all experiments are completed, terminate the Prefect server.</p> <pre><code>prefect server stop\n</code></pre>"},{"location":"tutorials/01_getting_started/#see-also","title":"See Also","text":"<p>In this tutorial, you run the workflow as a local Python script.  If the experiment takes longer to run or needs to be run on a regular basis, it becomes hard to manage such local Python processes. </p> <p>In such a situation, you can deploy the workflow to a self-hosted remote workflow server or Prefect Cloud.  Visit Prefect Deploy Guide to find instructions.</p> <p>Experiment results can be also saved as Artifacts.</p>"}]}